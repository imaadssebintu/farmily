<link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Outfit:wght@400;600;700&display=swap"
    rel="stylesheet">
<div class="tree-header">
    <div class="header-left">
        <h1 class="page-title">Family Tree</h1>
        <p class="page-subtitle">Tracing generations, preserving legacy</p>
    </div>
    <div class="header-right">
        <div class="tree-search">
            <span class="search-icon">üîç</span>
            <input type="text" id="treeSearchInput" placeholder="Find a family member..."
                oninput="onTreeSearch(this.value)">
            <div id="treeSearchResults" class="search-dropdown" style="display: none;"></div>
        </div>
    </div>
</div>

<div class="tree-container" id="treeContainer">
    <!-- SVG will be injected here -->
</div>

<style>
    :root {
        --font-main: 'Inter', sans-serif;
        --font-display: 'Outfit', sans-serif;
    }

    body {
        font-family: var(--font-main);
    }

    .tree-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
        margin-bottom: 2rem;
        gap: 20px;
    }

    .page-title {
        font-family: var(--font-display);
        font-size: 2.5rem;
        font-weight: 700;
        background: linear-gradient(135deg, #f8fafc 0%, #3b82f6 100%);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        margin: 0;
        letter-spacing: -0.02em;
    }

    .page-subtitle {
        color: #94a3b8;
        font-size: 0.95rem;
        margin: 0.5rem 0 0 0;
        font-weight: 500;
    }

    .tree-container {
        width: 100%;
        height: calc(100vh - 220px);
        background-color: #020617;
        background-image:
            radial-gradient(circle at 2px 2px, rgba(30, 41, 59, 0.3) 1px, transparent 0);
        background-size: 32px 32px;
        border: 1px solid rgba(148, 163, 184, 0.1);
        border-radius: 2rem;
        overflow: hidden;
        position: relative;
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
    }

    .sidebar-family-list {
        display: flex;
        flex-direction: column;
        gap: 12px;
    }

    .family-item {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 8px 12px;
        background: #1e293b;
        border-radius: 8px;
        cursor: pointer;
        transition: background 0.2s;
        border: 1px solid transparent;
    }

    .family-item:hover {
        background: #273549;
        border-color: #3b82f6;
    }

    .family-item img {
        width: 32px;
        height: 32px;
        border-radius: 6px;
        background: #334155;
    }

    .family-item .name {
        font-size: 13px;
        font-weight: 500;
    }

    .family-item .rel {
        font-size: 11px;
        color: #64748b;
        margin-left: auto;
    }

    /* Dimming logic */
    .node.is-dimmed {
        opacity: 0.2;
        filter: grayscale(1);
    }

    .link.is-dimmed {
        opacity: 0.1;
    }

    /* Generation Lanes Background */
    .lane-even {
        fill: rgba(30, 41, 59, 0.3);
    }

    .lane-odd {
        fill: transparent;
    }

    .lane-label {
        font-family: var(--font-display);
        font-size: 11px;
        font-weight: 700;
        fill: #3b82f6;
        text-transform: uppercase;
        letter-spacing: 0.1em;
        pointer-events: none;
        opacity: 0.9;
    }

    .lane-divider {
        stroke: rgba(148, 163, 184, 0.05);
        stroke-width: 1px;
        stroke-dasharray: 4, 4;
    }

    .timeline-bg {
        fill: #020617;
        opacity: 0.8;
    }

    .timeline-line {
        stroke: rgba(59, 130, 246, 0.2);
        stroke-width: 2px;
    }

    .timeline-dot {
        fill: #3b82f6;
        stroke: #020617;
        stroke-width: 2px;
    }

    /* Grid pattern removed from pseudo-element to ensure it stays behind SVG */

    .tree-card {
        width: 220px;
        height: 80px;
        background: rgba(30, 41, 59, 0.85);
        backdrop-filter: blur(12px);
        border: 1px solid rgba(148, 163, 184, 0.1);
        border-radius: 12px;
        padding: 12px;
        color: white;
        cursor: pointer;
        transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
        display: flex;
        align-items: center;
        gap: 12px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        position: relative;
        /* overflow: hidden; removed to prevent shadow clipping */
    }

    .tree-card::after {
        content: '';
        position: absolute;
        bottom: 1px;
        left: 1px;
        right: 1px;
        height: 3px;
        background: var(--indicator-color, #334155);
        border-bottom-left-radius: 11px;
        border-bottom-right-radius: 11px;
        opacity: 0.8;
        transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
        pointer-events: none;
    }

    .tree-card:hover::after {
        bottom: 2px;
        left: 2px;
        right: 2px;
        height: 4px;
        opacity: 1;
        filter: brightness(1.2);
    }

    .tree-card:hover {
        background: rgba(30, 41, 59, 1);
        border-color: #3b82f6;
        transform: translateY(-6px) scale(1.05);
        box-shadow: 0 15px 35px rgba(59, 130, 246, 0.3);
        z-index: 50;
    }

    .tree-card.is-active {
        border-color: #3b82f6;
        background: #26334a;
        box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.2);
    }

    .card-photo {
        width: 48px;
        height: 48px;
        border-radius: 10px;
        background: #334155;
        object-fit: cover;
        flex-shrink: 0;
        border: 1px solid rgba(255, 255, 255, 0.1);
        transition: transform 0.3s;
    }

    .tree-card:hover .card-photo {
        transform: scale(1.1);
    }

    .card-content {
        display: flex;
        flex-direction: column;
        gap: 2px;
        overflow: hidden;
    }

    .card-name {
        font-weight: 600;
        font-size: 14px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        color: #f8fafc;
    }

    .card-lifespan {
        font-size: 11px;
        color: #94a3b8;
        font-family: 'JetBrains Mono', monospace;
    }

    .card-gender {
        position: absolute;
        top: 8px;
        right: 8px;
        font-size: 10px;
        opacity: 0.5;
    }

    .link {
        stroke: #475569;
        stroke-opacity: 0.2;
        stroke-width: 2px;
        fill: none;
        transition: all 0.4s;
    }

    .link.is-highlighted {
        stroke-opacity: 1;
        stroke-width: 3px;
        stroke: #3b82f6;
        filter: drop-shadow(0 0 8px rgba(59, 130, 246, 0.5));
    }

    .link-spouse {
        stroke: #d946ef;
        stroke-width: 2.5px;
        stroke-dasharray: 6, 4;
        stroke-opacity: 0.4;
    }

    /* Search Component Glassmorphism */
    .tree-search {
        position: relative;
        width: 320px;
    }

    .tree-search input {
        width: 100%;
        background: rgba(30, 41, 59, 0.5);
        backdrop-filter: blur(12px);
        border: 1px solid rgba(148, 163, 184, 0.1);
        border-radius: 14px;
        padding: 12px 15px 12px 45px;
        color: white;
        font-size: 14px;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    .tree-search input:focus {
        outline: none;
        border-color: #3b82f6;
        background: rgba(30, 41, 59, 0.8);
        box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.15);
        transform: translateY(-1px);
    }

    .search-icon {
        position: absolute;
        left: 18px;
        top: 50%;
        transform: translateY(-50%);
        opacity: 0.6;
        font-size: 16px;
    }

    .search-dropdown {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: #1e293b;
        border: 1px solid #334155;
        border-top: none;
        border-radius: 0 0 10px 10px;
        max-height: 300px;
        overflow-y: auto;
        z-index: 20;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
    }

    .search-result {
        padding: 10px 15px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 10px;
        transition: background 0.2s;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .search-result:hover {
        background: #334155;
    }

    .search-result .photo {
        width: 32px;
        height: 32px;
        border-radius: 6px;
        background: #475569;
    }

    .search-result .name {
        font-size: 13px;
        font-weight: 500;
    }

    /* Zoom Controls */
    .zoom-controls {
        position: absolute;
        bottom: 24px;
        right: 24px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        z-index: 10;
    }

    .zoom-btn {
        width: 44px;
        height: 44px;
        border-radius: 12px;
        background: rgba(30, 41, 59, 0.8);
        backdrop-filter: blur(8px);
        border: 1px solid rgba(148, 163, 184, 0.1);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 18px;
        transition: all 0.2s;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }

    .zoom-btn:hover {
        background: #3b82f6;
        border-color: #3b82f6;
    }

    /* Fullscreen specific */
    .tree-container:fullscreen {
        width: 100vw;
        height: 100vh;
        border-radius: 0;
        border: none;
    }

    /* Family Sidebar Styles */
    .family-sidebar {
        position: fixed;
        top: 0;
        right: -400px;
        width: 400px;
        height: 100vh;
        background: rgba(15, 23, 42, 0.95);
        backdrop-filter: blur(20px);
        border-left: 1px solid rgba(148, 163, 184, 0.1);
        z-index: 1000;
        padding: 40px 24px;
        transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1);
        overflow-y: auto;
        box-shadow: -10px 0 40px rgba(0, 0, 0, 0.5);
    }

    .family-sidebar.is-open {
        right: 0;
    }

    .sidebar-close {
        position: absolute;
        top: 20px;
        right: 20px;
        background: none;
        border: none;
        color: #94a3b8;
        font-size: 24px;
        cursor: pointer;
        transition: color 0.2s;
    }

    .sidebar-close:hover {
        color: white;
    }

    .sidebar-photo {
        width: 120px;
        height: 120px;
        border-radius: 20px;
        object-fit: cover;
        margin-bottom: 20px;
        border: 2px solid rgba(59, 130, 246, 0.5);
    }

    .sidebar-name {
        font-size: 24px;
        font-weight: 700;
        margin-bottom: 4px;
        color: white;
    }

    .sidebar-meta {
        font-size: 14px;
        color: #94a3b8;
        margin-bottom: 30px;
        font-family: 'JetBrains Mono', monospace;
    }

    .sidebar-section {
        margin-bottom: 30px;
    }

    .sidebar-section h3 {
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: #475569;
        margin-bottom: 12px;
    }

    .sidebar-bio {
        font-size: 14px;
        line-height: 1.6;
        color: #cbd5e1;
    }

    .sidebar-footer {
        margin-top: 40px;
        padding-top: 20px;
        border-top: 1px solid rgba(148, 163, 184, 0.1);
    }

    .btn-full-profile {
        display: block;
        width: 100%;
        padding: 12px;
        background: #3b82f6;
        color: white;
        text-align: center;
        border-radius: 10px;
        text-decoration: none;
        font-weight: 600;
        transition: all 0.2s;
    }

    .btn-full-profile:hover {
        background: #2563eb;
        transform: translateY(-2px);
    }

    /* Mobile Responsiveness */
    @media (max-width: 768px) {

        .header-left,
        .header-right {
            width: 100%;
            text-align: center;
        }

        .header-right {
            margin-top: 20px;
            display: flex;
            justify-content: center;
        }

        .tree-search {
            width: 100%;
            max-width: 100%;
        }

        .tree-container {
            height: calc(100vh - 280px);
            /* More space for header */
            border-radius: 1rem;
        }

        .family-sidebar {
            width: 100%;
            right: -100%;
        }

        .zoom-controls {
            bottom: 16px;
            right: 16px;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
        }
    }
</style>

<div class="zoom-controls">
    <button class="zoom-btn" onclick="toggleFullscreen()" title="Fullscreen">‚õ∂</button>
    <button class="zoom-btn" onclick="zoomIn()" title="Zoom In">+</button>
    <button class="zoom-btn" onclick="zoomOut()" title="Zoom Out">-</button>
    <button class="zoom-btn" onclick="resetZoom()" title="Reset View">‚ü≤</button>
</div>
<div id="treeTooltip" class="tree-tooltip"></div>

<!-- Family Sidebar -->
<div id="familySidebar" class="family-sidebar">
    <button class="sidebar-close" onclick="closeSidebar()">&times;</button>
    <img id="sidebarPhoto" src="" class="sidebar-photo">
    <h2 id="sidebarName" class="sidebar-name"></h2>
    <div id="sidebarMeta" class="sidebar-meta"></div>

    <div class="sidebar-section">
        <h3>Biography</h3>
        <p id="sidebarBio" class="sidebar-bio"></p>
    </div>

    <div class="sidebar-section">
        <h3>Immediate Family</h3>
        <div id="sidebarFamilyList" class="sidebar-family-list"></div>
    </div>

    <div class="sidebar-footer">
        <a id="btnFullProfile" href="#" class="btn-full-profile">View Full Profile</a>
    </div>
</div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
    let nodeMap = new Map();
    let currentData = null;
    let svg, g, simulation, zoom;

    function formatLifespan(person) {
        if (!person.birth_date && !person.death_date) return 'Unknown';

        const birthYear = person.birth_date ? new Date(person.birth_date).getFullYear() : '???';
        const deathYear = person.death_date ? new Date(person.death_date).getFullYear() : (person.is_living ? 'Present' : '???');

        let age = '';
        if (person.birth_date) {
            const birth = new Date(person.birth_date);
            const ref = person.death_date ? new Date(person.death_date) : new Date();
            age = ` (${Math.floor((ref - birth) / (1000 * 60 * 60 * 24 * 365.25))}y)`;
        }

        return `${birthYear} - ${deathYear}${age}`;
    }

    function onTreeSearch(query) {
        const results = document.getElementById('treeSearchResults');
        if (!query || query.length < 2) {
            results.style.display = 'none';
            return;
        }

        const filtered = currentData.nodes.filter(n => n.name.toLowerCase().includes(query.toLowerCase()));

        if (filtered.length > 0) {
            results.innerHTML = filtered.map(n => `
                <div class="search-result" onclick="focusOnNode('${n.id}')">
                    <img src="${n.photo_url || 'https://api.dicebear.com/7.x/initials/svg?seed=' + n.name}" class="photo">
                    <div class="name">${n.name}</div>
                </div>
            `).join('');
            results.style.display = 'block';
        } else {
            results.innerHTML = '<div class="search-result">No results found</div>';
            results.style.display = 'block';
        }
    }

    function toggleFullscreen() {
        const container = document.getElementById('treeContainer');
        if (!document.fullscreenElement) {
            container.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable full-screen mode: ${err.message}`);
            });
        } else {
            document.exitFullscreen();
        }
    }

    function focusOnNode(id) {
        const node = currentData.nodes.find(n => n.id === id);
        if (node) {
            document.getElementById('treeSearchResults').style.display = 'none';
            document.getElementById('treeSearchInput').value = '';

            const transform = d3.zoomIdentity
                .translate(svg.node().clientWidth / 2 - node.x, svg.node().clientHeight / 2 - node.y)
                .scale(1.2);

            svg.transition().duration(750)
                .call(zoom.transform, transform);

            // Highlight briefly?
            d3.select(`[data-node-id="${id}"]`).transition()
                .duration(200).style("filter", "brightness(1.5)")
                .transition().duration(800).style("filter", "none");
        }
    }

    function closeSidebar() {
        document.getElementById('familySidebar').classList.remove('is-open');
        d3.selectAll(".node").classList.remove("is-active");
        highlightLineage(null);
    }

    function openSidebar(id) {
        const person = nodeMap.get(id);
        if (!person) return;

        document.getElementById('sidebarPhoto').src = person.photo_url || `https://api.dicebear.com/7.x/initials/svg?seed=${person.name}`;
        document.getElementById('sidebarName').textContent = person.name;
        document.getElementById('sidebarMeta').textContent = `${person.gender} ‚Ä¢ ${formatLifespan(person)}`;
        document.getElementById('sidebarBio').textContent = person.biography || "No biography available.";
        document.getElementById('btnFullProfile').href = `/people/${person.id}`;

        document.getElementById('familySidebar').classList.add('is-open');

        // Populate Family List
        const familyList = document.getElementById('sidebarFamilyList');
        const relatives = [];
        currentData.links.forEach(l => {
            if (l.source.id === id || l.target.id === id) {
                const otherID = l.source.id === id ? l.target.id : l.source.id;
                const other = nodeMap.get(otherID);
                if (other) {
                    relatives.push({ ...other, type: l.type });
                }
            }
        });

        familyList.innerHTML = relatives.length > 0 ? relatives.map(r => `
            <div class="family-item" onclick="focusOnNode('${r.id}'); openSidebar('${r.id}')">
                <img src="${r.photo_url || 'https://api.dicebear.com/7.x/initials/svg?seed=' + r.name}">
                <div class="name">${r.name}</div>
                <div class="rel">${r.type}</div>
            </div>
        `).join('') : '<p class="sidebar-bio">No immediate family found.</p>';

        // Highlight in tree
        d3.selectAll(".tree-card").classed("is-active", d => d.id === id);
        highlightLineage(id);
    }

    function highlightLineage(id) {
        if (!id) {
            d3.selectAll(".node").classed("is-dimmed", false);
            d3.selectAll(".link").classed("is-dimmed", false).classed("is-highlighted", false);
            return;
        }

        const relatedNodes = new Set([id]);
        const relatedLinks = new Set();

        // 1. Trace Ancestors
        const traceAncestors = (nodeID) => {
            currentData.links.forEach(l => {
                if (l.type === 'child' && l.source.id === nodeID) { // source is child of target
                    relatedNodes.add(l.target.id);
                    relatedLinks.add(l.source.id + "-" + l.target.id);
                    traceAncestors(l.target.id);
                } else if (l.type === 'parent' && l.target.id === nodeID) { // target is parent of source
                    relatedNodes.add(l.source.id);
                    relatedLinks.add(l.source.id + "-" + l.target.id);
                    traceAncestors(l.source.id);
                }
            });
        };

        // 2. Trace Descendants
        const traceDescendants = (nodeID) => {
            currentData.links.forEach(l => {
                if (l.type === 'parent' && l.source.id === nodeID) { // source is parent of target
                    relatedNodes.add(l.target.id);
                    relatedLinks.add(l.source.id + "-" + l.target.id);
                    traceDescendants(l.target.id);
                } else if (l.type === 'child' && l.target.id === nodeID) { // target is child of source
                    relatedNodes.add(l.source.id);
                    relatedLinks.add(l.source.id + "-" + l.target.id);
                    traceDescendants(l.source.id);
                }
            });
        };

        // 3. Spouses
        currentData.links.forEach(l => {
            if (l.type === 'spouse' && (l.source.id === id || l.target.id === id)) {
                relatedNodes.add(l.source.id);
                relatedNodes.add(l.target.id);
                relatedLinks.add(l.source.id + "-" + l.target.id);
            }
        });

        traceAncestors(id);
        traceDescendants(id);

        // 3. Proactively include "Other Parents" of any children in the traced set
        // This ensures the family union is shown even when hovering from above
        currentData.links.forEach(l => {
            if (l.type === 'parent' || l.type === 'child') {
                const childID = (l.type === 'parent') ? (l.target.id || l.target) : (l.source.id || l.source);
                const parentID = (l.type === 'parent') ? (l.source.id || l.source) : (l.target.id || l.target);

                if (relatedNodes.has(typeof childID === 'object' ? childID.id : childID)) {
                    // This node is a parent of someone in the traced set
                    relatedNodes.add(typeof parentID === 'object' ? parentID.id : parentID);
                    relatedLinks.add((typeof parentID === 'object' ? parentID.id : parentID) + "-" + (typeof childID === 'object' ? childID.id : childID));
                }
            }
        });

        // 4. Trace Spouses of any related nodes found
        currentData.links.forEach(l => {
            const sID = l.source.id || l.source;
            const tID = l.target.id || l.target;
            if (l.type === 'spouse' && relatedNodes.has(sID) && relatedNodes.has(tID)) {
                relatedLinks.add(sID + "-" + tID);
            }
        });

        d3.selectAll(".node").classed("is-dimmed", d => !relatedNodes.has(d.id));
        d3.selectAll(".link").classed("is-dimmed", d => {
            const linkID = d.source.id + "-" + d.target.id;
            return !relatedLinks.has(linkID);
        }).classed("is-highlighted", d => {
            const linkID = d.source.id + "-" + d.target.id;
            return relatedLinks.has(linkID);
        });
    }

    async function initTree() {
        const container = document.getElementById('treeContainer');
        const width = container.clientWidth;
        const height = container.clientHeight;

        try {
            const response = await fetch('/api/tree/data');
            const result = await response.json();

            if (!result.success) return;

            currentData = result.data;
            nodeMap = new Map(currentData.nodes.map(n => [n.id, n]));
            // Reset levels
            currentData.nodes.forEach(n => {
                n.level = -1;
                n.isSpouse = false;
                n.spouses = [];
            });

            // 1. Identify Spouses first to treat them as units
            currentData.links.forEach(l => {
                if (l.type === 'spouse') {
                    const s = nodeMap.get(l.source.id || l.source);
                    const t = nodeMap.get(l.target.id || l.target);
                    if (s && t) {
                        s.isSpouse = true;
                        t.isSpouse = true;
                        if (!s.spouses.includes(t.id)) s.spouses.push(t.id);
                        if (!t.spouses.includes(s.id)) t.spouses.push(s.id);
                    }
                }
            });

            // 2. Iterative Level Propagation
            // Start by setting nodes with no parents to level 0
            currentData.nodes.forEach(n => {
                const hasParents = currentData.links.some(l =>
                    (l.type === 'parent' && (l.target.id || l.target) === n.id) ||
                    (l.type === 'child' && (l.source.id || l.source) === n.id)
                );
                if (!hasParents) n.level = 0;
            });

            // Propagate levels through parents and spouses
            for (let i = 0; i < 10; i++) { // Run multiple passes to stabilize
                let changed = false;

                // Parent -> Child propagation
                currentData.links.forEach(l => {
                    const s = nodeMap.get(l.source.id || l.source);
                    const t = nodeMap.get(l.target.id || l.target);
                    if (!s || !t) return;

                    if (l.type === 'parent') {
                        if (s.level !== -1 && t.level <= s.level) {
                            t.level = s.level + 1;
                            changed = true;
                        }
                    } else if (l.type === 'child') {
                        if (t.level !== -1 && s.level <= t.level) {
                            s.level = t.level + 1;
                            changed = true;
                        }
                    }
                });

                // Spouse alignment (spouses must stay on same level)
                currentData.links.forEach(l => {
                    if (l.type === 'spouse') {
                        const s = nodeMap.get(l.source.id || l.source);
                        const t = nodeMap.get(l.target.id || l.target);
                        if (s && t && s.level !== t.level) {
                            const maxL = Math.max(s.level, t.level);
                            if (maxL !== -1) {
                                s.level = maxL;
                                t.level = maxL;
                                changed = true;
                            }
                        }
                    }
                });

                if (!changed) break;
            }

            // Ensure no negative levels (disconnected nodes)
            currentData.nodes.forEach(n => { if (n.level === -1) n.level = 0; });

            const maxLevel = d3.max(currentData.nodes, d => d.level) || 0;

            // Sort and Position Nodes Hierarchically to prevent crossings
            const levels = [];
            for (let i = 0; i <= maxLevel; i++) {
                levels[i] = currentData.nodes.filter(n => n.level === i);
            }

            // Grid-based Hierarchical Slotting to guarantee no crossings
            levels.forEach((levelNodes, i) => {
                if (i === 0) {
                    levelNodes.forEach((n, idx) => {
                        n.x = (width / (levelNodes.length + 1)) * (idx + 1);
                    });
                } else {
                    // Sort nodes by their parent's average X to preserve hierarchical flow
                    levelNodes.sort((a, b) => {
                        const getParentAvgX = (node) => {
                            const parents = currentData.links
                                .filter(l => (l.type === 'parent' || l.type === 'child'))
                                .filter(l => (l.source.id === node.id && l.target.level < node.level) ||
                                    (l.target.id === node.id && l.source.level < node.level))
                                .map(l => l.source.id === node.id ? l.target.x : l.source.x);
                            return d3.mean(parents) || width / 2;
                        };
                        return getParentAvgX(a) - getParentAvgX(b);
                    });

                    // Assign slots with wide spacing
                    const slotWidth = 320;
                    const totalWidth = (levelNodes.length - 1) * slotWidth;
                    const startX = (width - totalWidth) / 2;

                    levelNodes.forEach((n, idx) => {
                        n.x = startX + (idx * slotWidth);
                    });
                }
            });

            svg = d3.select("#treeContainer").append("svg")
                .attr("width", "100%")
                .attr("height", "100%")
                .on("click", (event) => {
                    // If we clicked directly on the SVG background (not a bubble from a card)
                    if (event.target.tagName === 'svg') {
                        closeSidebar();
                    }
                });

            zoom = d3.zoom().scaleExtent([0.1, 3]).on("zoom", (e) => g.attr("transform", e.transform));
            svg.call(zoom);

            window.zoomIn = () => svg.transition().call(zoom.scaleBy, 1.4);
            window.zoomOut = () => svg.transition().call(zoom.scaleBy, 0.6);
            window.resetZoom = () => svg.transition().call(zoom.transform, d3.zoomIdentity.translate(width / 2 - 110, 100).scale(0.8));

            g = svg.append("g");

            // Generation Timeline & Lanes
            const laneHeight = 280;
            const lanes = g.append("g").attr("class", "lanes");
            const timeline = g.append("g").attr("class", "timeline");

            // Left margin for timeline
            const timelineX = 40;

            for (let i = 0; i <= maxLevel; i++) {
                // Background Lane
                lanes.append("rect")
                    .attr("x", -10000)
                    .attr("y", i * laneHeight - laneHeight / 2)
                    .attr("width", 20000)
                    .attr("height", laneHeight)
                    .attr("class", i % 2 === 0 ? "lane-even" : "lane-odd");

                // Timeline Components (Sticky-like sidebar)
                const yPos = i * laneHeight;

                // Timeline marker line
                timeline.append("line")
                    .attr("x1", timelineX)
                    .attr("y1", yPos - laneHeight / 2)
                    .attr("x2", timelineX)
                    .attr("y2", yPos + laneHeight / 2)
                    .attr("class", "timeline-line");

                // Connector dot
                timeline.append("circle")
                    .attr("cx", timelineX)
                    .attr("cy", yPos)
                    .attr("r", 5)
                    .attr("class", "timeline-dot");

                // Label
                timeline.append("text")
                    .attr("x", timelineX + 20)
                    .attr("y", yPos + 4)
                    .attr("class", "lane-label")
                    .text(`Generation ${i + 1}`);
            }

            svg.call(zoom.transform, d3.zoomIdentity.translate(width / 2 - 110, 100).scale(0.8));

            simulation = d3.forceSimulation(currentData.nodes)
                .force("link", d3.forceLink(currentData.links).id(d => d.id).distance(200).strength(0.5))
                .force("charge", d3.forceManyBody().strength(-5000))
                .force("collide", d3.forceCollide().radius(160).iterations(2))
                .force("y", d3.forceY(d => d.level * 280).strength(2))
                .force("x", d3.forceX(d => d.x).strength(0.3)) // Hold hierarchical positions more gently
                .force("center", d3.forceX(width / 2).strength(0.05)) // Global centering force
                .force("sibling", (alpha) => {
                    // Group siblings together
                    const levelGroups = d3.groups(currentData.nodes, d => d.level);
                    levelGroups.forEach(([lvl, lNodes]) => {
                        const families = d3.groups(lNodes, n => {
                            const parents = currentData.links
                                .filter(l => (l.type === 'parent' || l.type === 'child'))
                                .filter(l => {
                                    const sID = l.source.id || l.source;
                                    const tID = l.target.id || l.target;
                                    return sID === n.id || tID === n.id;
                                })
                                .map(l => {
                                    const sID = l.source.id || l.source;
                                    const tID = l.target.id || l.target;
                                    return sID === n.id ? tID : sID;
                                })
                                .sort()
                                .join(",");
                            return parents || 'orphaned';
                        });

                        families.forEach(([fID, fNodes]) => {
                            if (fID === 'orphaned' || fNodes.length < 2) return;
                            const center = d3.mean(fNodes, d => d.x);
                            fNodes.forEach(d => {
                                d.vx += (center - d.x) * alpha * 0.1;
                            });
                        });
                    });
                })
                .force("spouse", (alpha) => {
                    currentData.links.forEach(l => {
                        if (l.type === 'spouse') {
                            const s = nodeMap.get(typeof l.source === 'object' ? l.source.id : l.source);
                            const t = nodeMap.get(typeof l.target === 'object' ? l.target.id : l.target);
                            if (s && t) {
                                const dist = s.x - t.x;
                                const targetDist = 240;
                                const move = (Math.abs(dist) - targetDist) * alpha * 0.5;
                                if (dist > 0) { s.vx -= move; t.vx += move; }
                                else { s.vx += move; t.vx -= move; }
                            }
                        }
                    });
                });

            // 1. Create Link Group (rendered first = bottom layer)
            const link = g.append("g")
                .selectAll("path")
                .data(currentData.links)
                .enter().append("path")
                .attr("class", d => d.type === 'spouse' ? 'link link-spouse' : 'link');

            // 2. Create Node Group (rendered second = top layer)
            const node = g.append("g")
                .selectAll("g")
                .data(currentData.nodes)
                .enter().append("g")
                .attr("class", "node")
                .attr("data-node-id", d => d.id)
                .on("mouseover", (e, d) => !document.getElementById('familySidebar').classList.contains('is-open') && highlightLineage(d.id))
                .on("mouseout", (e, d) => !document.getElementById('familySidebar').classList.contains('is-open') && highlightLineage(null))
                .call(d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended));

            node.append("foreignObject")
                .attr("width", 320)
                .attr("height", 160)
                .attr("x", -160)
                .attr("y", -80)
                .style("pointer-events", "none") // Let pointer events pass to the card
                .append("xhtml:div")
                .style("width", "100%")
                .style("height", "100%")
                .style("display", "flex")
                .style("align-items", "center")
                .style("justify-content", "center")
                .style("pointer-events", "none")
                .html(d => {
                    const indicatorColor = d.gender === 'Male' ? '#3b82f6' : (d.gender === 'Female' ? '#ec4899' : '#10b981');
                    const photo = d.photo_url || `https://api.dicebear.com/7.x/initials/svg?seed=${d.name}`;
                    return `
                        <div class="tree-card" style="--indicator-color: ${indicatorColor}; pointer-events: auto;" 
                            onclick="event.stopPropagation(); openSidebar('${d.id}')">
                            <img src="${photo}" class="card-photo">
                            <div class="card-content">
                                <div class="card-name">${d.name}</div>
                                <div class="card-lifespan">${formatLifespan(d)}</div>
                            </div>
                            <div class="card-gender">${d.gender === 'Male' ? '‚ôÇ' : (d.gender === 'Female' ? '‚ôÄ' : 'üß¨')}</div>
                        </div>
                    `;
                });

            // Organic Bezier Curves for vertical links
            const curveGenerator = d3.linkVertical()
                .x(d => d.x)
                .y(d => d.y);

            function getLinkPath(d) {
                if (d.type === 'spouse') {
                    // Force a perfectly horizontal line by using the calculated level height
                    const y = d.source.level * laneHeight;
                    return `M${d.source.x},${y} L${d.target.x},${y}`;
                }

                // Parent-Child Union Logic
                const child = d.source.level > d.target.level ? d.source : d.target;
                const parent = d.source.level > d.target.level ? d.target : d.source;

                // Find if the child has another parent in the tree
                const otherParentLink = currentData.links.find(l =>
                    (l.source.id === child.id || l.target.id === child.id) &&
                    (l.source.id !== parent.id && l.target.id !== parent.id) &&
                    (l.type === 'parent' || l.type === 'child')
                );

                let sourceX = parent.x;
                let sourceY = parent.y + 40;

                if (otherParentLink) {
                    const otherParentID = otherParentLink.source.id === child.id ? otherParentLink.target.id : otherParentLink.source.id;
                    const otherParent = nodeMap.get(otherParentID);

                    // Check if they are spouses
                    const isSpouse = currentData.links.some(l =>
                        l.type === 'spouse' &&
                        ((l.source.id === parent.id && l.target.id === otherParent.id) ||
                            (l.source.id === otherParent.id && l.target.id === parent.id))
                    );

                    if (isSpouse) {
                        // Use midpoint of the spouse line as the source
                        sourceX = (parent.x + otherParent.x) / 2;
                        sourceY = (parent.y + otherParent.y) / 2;

                        // Vertical "stem" starts here
                        const targetY = child.y - 40;
                        const midY = (sourceY + targetY) / 2;

                        // We also need to draw a tiny vertical line from the spouse line center to start the curve
                        // But for simplicity, we'll just curve from the midpoint
                        return `M${sourceX},${sourceY} C${sourceX},${midY} ${child.x},${midY} ${child.x},${targetY}`;
                    }
                }

                // Default vertical curve
                const targetY = child.y - 40;
                const midY = (sourceY + targetY) / 2;
                return `M${sourceX},${sourceY} C${sourceX},${midY} ${child.x},${midY} ${child.x},${targetY}`;
            }

            simulation.on("tick", () => {
                // Hard-lock Y to generational lanes to prevent any degree/slant
                currentData.nodes.forEach(d => {
                    d.y = d.level * laneHeight;
                    d.vy = 0; // Kill vertical velocity
                });
                link.attr("d", getLinkPath);
                node.attr("transform", d => `translate(${d.x},${d.y})`);
            });

            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x; d.fy = d.y;
            }
            function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
            function dragended(event, d) { if (!event.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; }

        } catch (error) {
            console.error('Error initializing tree:', error);
        }
    }

    // Handle window resize
    window.addEventListener('resize', () => {
        d3.select("#treeContainer svg").remove();
        initTree();
    });

    initTree();
</script>